import cookieParser from 'cookie-parser';
import cors from 'cors';
import express from 'express';
import helmet from 'helmet';
import http from 'node:http';
import { HealthCheckError, createTerminus } from '@godaddy/terminus';
import { LoggerFactory, LoggerType } from '@vue-storefront/logger';
import merge from 'lodash.merge';
import multer from 'multer';
import xss from 'xss';
import { setTimeout } from 'node:timers/promises';

/**
 * Resolves dependencies based on the current working directory, not relative to this package.
 */
function resolveDependency(name, alokai) {
    try {
        // eslint-disable-next-line
        return require(require.resolve(name, { paths: [process.cwd()] }));
    }
    catch (error) {
        alokai.logger.error(error);
        throw new Error(`Could not resolve integration "${name}". See the error above for more details.`);
    }
}

/**
 * Imports extensions from the current working directory if they're represented as strings.
 */
function lookUpExternal(alokai) {
    return function (extension) {
        return typeof extension === "string"
            ? resolveDependency(extension, alokai)
            : [extension];
    };
}

/**
 * Imports extensions if they're represented as strings.
 */
function createExtensions(rawExtensions, alokai) {
    return rawExtensions.flatMap(lookUpExternal(alokai));
}
/**
 * Creates an array of extensions schemas or their paths.
 */
function createRawExtensions(apiClient, integration) {
    const extensionsCreateFn = integration.extensions;
    const predefinedExtensions = apiClient.createApiClient._predefinedExtensions || [];
    return extensionsCreateFn
        ? extensionsCreateFn(predefinedExtensions)
        : predefinedExtensions;
}

const GLOBAL_MIDDLEWARE_CFG_KEY = Symbol("GLOBAL_MIDDLEWARE_CFG_KEY");
/**
 * Internal class responsible for spawning minimal amount of Logger's instances
 * on boostrap of the application.
 *
 * @example Spawning minimal amount of Logger's instances and accessing it
 * ```ts
 * const config = // ... it's whole middleware's config
 * const buildLogger = (loggerConfig) => LoggerFactory.create(LoggerType.ConsolaGcp, loggerConfig); // function responsible for creating new instance of Logger, it gets already resolved configuration for new instance as an argument
 *
 * const loggerManager = new LoggerManager(
 *  config,
 *  buildLogger
 * );
 * ```
 */
class LoggerManager {
    constructor(config, buildLogger) {
        this.instances = {};
        // Global Logger
        this.instances[GLOBAL_MIDDLEWARE_CFG_KEY] = this.selectLogger(config, buildLogger);
        // Logger for every integration having custom logger config
        for (const [integrationName, integrationEntry] of Object.entries(config.integrations)) {
            if (this.hasCustomLoggerConfig(integrationEntry)) {
                this.instances[integrationName] = this.selectLogger(this.mergeConfigs(integrationEntry, config), buildLogger, integrationName);
            }
        }
    }
    /**
     * Merges integration's logger config with global's logger config
     */
    mergeConfigs(integrationConfig, globalConfig) {
        return {
            ...integrationConfig,
            logger: {
                ...globalConfig.logger,
                ...integrationConfig.logger,
            },
        };
    }
    /**
     * Selects custom logger provided by user with fallback to default logger.
     * Prints console.warn if provided redudant custom options with custom handler.
     */
    selectLogger(config, buildLogger, tag = "global") {
        const logger = config.logger?.handler || buildLogger(config.logger);
        if (config.logger?.handler) {
            if (Object.keys(config.logger).length > 1) {
                /**
                 * This codeblock will be triggered if end-developer provided custom logger and custom options.
                 * As they might think custom options will be provided to the logger, then their logger could stop working.
                 * That's why we decided to use console instead of created logger here.
                 */
                // eslint-disable-next-line no-console
                console.warn(`Both handler and options are provided to ${tag} logger's options. Using handler, options will be ignored.`);
            }
        }
        return logger;
    }
    /**
     * Check if integration's config has configuration for dedicated logger instance.
     */
    hasCustomLoggerConfig(integrationEntry) {
        return Boolean(integrationEntry.logger);
    }
    /**
     * Returns instance of logger for requested integration from internal storage.
     * Called without an argument returns instance of global logger.
     */
    get(integrationName) {
        return (this.instances[integrationName] ||
            this.instances[GLOBAL_MIDDLEWARE_CFG_KEY]);
    }
}

/**
 * Unique key by which, we internally access original unlocked logger instance
 */
const UNLOCKED_LOGGER_KEY = Symbol("UNLOCKED_LOGGER_KEY");
/**
 * Wraps provided logger in guard function to prevent overwriting "alokai" key in metadata object.
 * It's private function of the package that cannot be exported.
 */
function lockLogger(logger) {
    return new Proxy(logger, {
        get(target, prop) {
            if (prop === UNLOCKED_LOGGER_KEY) {
                return logger;
            }
            return (...args) => {
                const [message, metadata] = args;
                const providedForbiddenMetadata = Boolean(metadata?.alokai);
                if (providedForbiddenMetadata) {
                    delete metadata.alokai;
                    target.warning("You attempted to overwrite alokai's metadata object. It's forbidden and your data will be removed.");
                }
                target[prop](message, {
                    ...metadata,
                });
            };
        },
    });
}
/**
 * Returns version of logger without guard.
 * It's private function of the package that cannot be exported.
 */
function unlockLogger(logger) {
    const unlockedLogger = logger[UNLOCKED_LOGGER_KEY];
    return unlockedLogger || logger;
}
/**
 * Function wrapping passed logger with additional metadata. So when log function is called
 * then metadata will be available without explicitly passing it.
 *
 * It solves a problem of having access to metadata in different moment than log function
 * is called.
 *
 * @remarks Multiple wrapping is supported. Use metadata parameter in passed getter to decide
 * which fields should be overwritten.
 */
function injectMetadata(logger, metadataGetter) {
    const unlockedLogger = unlockLogger(logger);
    const loggerWithMetadata = new Proxy(unlockedLogger, {
        get(target, prop) {
            const shouldSkipMethod = typeof target[prop] !== "function";
            if (!shouldSkipMethod) {
                return (...args) => {
                    const [message, metadata] = args;
                    target[prop](message, merge(metadata, metadataGetter(metadata)));
                };
            }
            return target[prop];
        },
    });
    return lockLogger(loggerWithMetadata);
}

/**
 * This logger is used as a fallback logger in case of any error during the
 * initialization of the logger. It is used to log the error and provide a
 * default logger for the application. It should not be used as a primary
 * logger.
 */
const fallbackLogger = injectMetadata(lockLogger(LoggerFactory.create(LoggerType.ConsolaGcp)), () => ({
    alokai: {
        context: "middleware",
    },
}));

function isAlokaiContainer(source) {
    return "logger" in source;
}
function isContext(source) {
    return "res" in source;
}
function findLogger(source) {
    if (isAlokaiContainer(source)) {
        return source?.logger;
    }
    const base = isContext(source) ? source?.res : source;
    return base?.locals?.alokai?.logger;
}
function getLogger(source) {
    const logger = findLogger(source);
    if (!logger) {
        fallbackLogger.alert("Logger instance could not be resolved", {
            troubleshooting: {
                message: "This issue is likely caused by a version mismatch in the middleware stack. Note: Logger functionality was introduced in version 5.1.0 of the middleware package. For more details, refer to https://docs.alokai.com/middleware/guides/logging.",
                steps: [
                    "Update all middleware packages to the latest compatible version to ensure logger compatibility.",
                    "Ensure API client packages are also updated, as they rely on compatible middleware versions.",
                    "Update unified API packages to the latest version to maintain compatibility with the updated middleware packages.",
                ],
            },
        });
        throw new Error("Logger instance could not be determined. In most cases, this is due to a versions missmatch in the middleware stack.");
    }
    return logger;
}

const isFunction = (x) => typeof x === "function";
// eslint-disable-next-line no-use-before-define
function includes(coll, el) {
    return coll.includes(el);
}

const STATUS_FIELDS = ["status", "statusCode"];
/**
 * @key is constant string identifier of connection error
 * @value is desired HTTP code that we are going to
 *  send back when we encounter specified connection error
 */
const CONNECTION_ERRORS = {
    ECONNABORTED: 408,
    ECONNRESET: 500,
};
function isErrorObject(obj) {
    // typeof null is 'object' https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null
    if (obj === null)
        return false;
    return typeof obj === "object";
}
function isAxiosError(error) {
    return "isAxiosError" in error;
}
function isApolloError(error) {
    return "networkError" in error || "code" in error;
}
function reduceStatus(narrowObject, depth) {
    return function reduceStatusNested(statusCode, key) {
        if (statusCode) {
            return statusCode;
        }
        if (includes(STATUS_FIELDS, key)) {
            return narrowObject[key] || null;
        }
        const newDepth = depth + 1;
        // eslint-disable-next-line no-use-before-define
        return obtainStatusCode(narrowObject[key], newDepth);
    };
}
function obtainStatusCode(givenObject, depth = 1) {
    const obj = givenObject || {};
    if (depth > 3) {
        return null;
    }
    return Object.keys(obj).reduce(reduceStatus(obj, depth), null);
}
function getAxiosStatusCode(error) {
    if (error?.code && CONNECTION_ERRORS[error.code]) {
        return CONNECTION_ERRORS[error.code];
    }
    return error.response?.status;
}
function getApolloStatusCode(error) {
    if (error.networkError) {
        return 500;
    }
    if (error.code) {
        return typeof error.code === "string" ? 400 : error.code;
    }
    if (error?.graphQLErrors?.length > 0) {
        return 200;
    }
    return undefined;
}
function getCodeFromError(error) {
    if (!isErrorObject(error)) {
        return undefined;
    }
    if (isAxiosError(error)) {
        return getAxiosStatusCode(error);
    }
    if (isApolloError(error)) {
        return getApolloStatusCode(error);
    }
    return obtainStatusCode(error);
}
function getAgnosticStatusCode(error) {
    return getCodeFromError(error) || 500;
}

async function getInitConfig({ apiClient, tag, integration, alokai, }) {
    const logger = getLogger(alokai);
    if (isFunction(apiClient?.init)) {
        try {
            logger.debug(`- Integration: ${tag} init function Start!`);
            const initConfig = await apiClient.init(integration.configuration, alokai);
            logger.debug(`- Integration: ${tag} init function Done!`);
            return initConfig;
        }
        catch (error) {
            const loggerWithErrorBoundary = injectMetadata(logger, () => ({
                alokai: {
                    errorBoundary: {
                        integrationName: tag,
                        type: "bootstrapHook",
                        hookName: "init",
                    },
                },
            }));
            loggerWithErrorBoundary.error(error);
            throw Error(`Error during executing init function in ${tag} integration. Error message: ${error}`);
        }
    }
    return {};
}

/**
 * Default error handler for the middleware
 */
const defaultErrorHandler = (error, _req, res) => {
    const status = getAgnosticStatusCode(error);
    res.status(status);
    if (status < 500) {
        /**
         * For all 4xx error codes or client error codes we wanted to send the error message
         */
        res.send({ message: getClientSideErrorMessage(error, status) });
    }
    else {
        /**
         * For all other error codes we wanted to send a generic error message
         */
        res.send("ServerError: Something went wrong. Please, check the logs for more details.");
    }
};
const getClientSideErrorMessage = (error, status) => {
    if (typeof error === "object" &&
        error !== null &&
        "message" in error &&
        typeof error.message === "string") {
        return error.message;
    }
    return `Request failed with status code ${status}`;
};

function buildAlokaiContainer(tag, loggerManager) {
    const logger = loggerManager.get(tag);
    const loggerWithMetadata = injectMetadata(logger, () => ({
        alokai: {
            context: "middleware",
        },
    }));
    return { logger: loggerWithMetadata };
}
async function triggerExtendAppHook(tag, extensions, app, configuration, alokai) {
    const logger = getLogger(alokai);
    for (const { name, extendApp } of extensions) {
        logger.debug(`- Loading: ${tag} extension: ${name}`);
        if (extendApp) {
            const loggerWithMetadata = injectMetadata(logger, () => ({
                alokai: {
                    scope: {
                        integrationName: tag,
                        extensionName: name,
                        type: "bootstrapHook",
                        hookName: "extendApp",
                    },
                },
            }));
            try {
                await extendApp({ app, configuration, logger: loggerWithMetadata });
            }
            catch (e) {
                const loggerWithErrorBoundary = injectMetadata(loggerWithMetadata, () => ({
                    alokai: {
                        errorBoundary: {
                            integrationName: tag,
                            extensionName: name,
                            type: "bootstrapHook",
                            hookName: "extendApp",
                        },
                    },
                }));
                loggerWithErrorBoundary.error(e);
                throw e;
            }
        }
    }
}
async function loadIntegration(tag, integration, app, alokai) {
    const apiClient = resolveDependency(integration.location, alokai);
    const rawExtensions = createRawExtensions(apiClient, integration);
    const extensions = createExtensions(rawExtensions, alokai);
    const loggerWithMetadata = injectMetadata(getLogger(alokai), () => ({
        alokai: {
            scope: {
                hookName: "init",
                type: "bootstrapHook",
                integrationName: tag,
            },
        },
    }));
    const initConfig = await getInitConfig({
        apiClient,
        integration,
        tag,
        alokai: {
            ...alokai,
            logger: loggerWithMetadata,
        },
    });
    const configuration = {
        ...integration.configuration,
        integrationName: tag,
    };
    await triggerExtendAppHook(tag, extensions, app, configuration, alokai);
    return {
        apiClient,
        extensions,
        initConfig,
        configuration,
    };
}
async function registerIntegrations(app, integrations, loggerManager) {
    const loadedIntegrations = {};
    for (const [tag, integration] of Object.entries(integrations)) {
        const alokai = buildAlokaiContainer(tag, loggerManager);
        const logger = getLogger(alokai);
        logger.debug(`- Loading: ${tag} ${integration.location}`);
        const { apiClient, extensions, initConfig, configuration } = await loadIntegration(tag, integration, app, alokai);
        loadedIntegrations[tag] = {
            apiClient,
            extensions,
            initConfig,
            configuration,
            customQueries: integration.customQueries,
            errorHandler: integration.errorHandler ?? defaultErrorHandler,
        };
        logger.debug(`- Integration: ${tag} loaded!`);
    }
    return loadedIntegrations;
}

const DEFAULT_OPTIONS = {
    enabled: true,
    maxFileSize: 5 * 1024 * 1024, // 5MB
    maxFiles: 5,
    allowedMimeTypes: ["image/*", "application/pdf"],
};
function createMulterMiddleware(options) {
    const config = { ...DEFAULT_OPTIONS, ...options };
    if (!config.enabled) {
        return undefined;
    }
    const storage = multer.memoryStorage();
    const maxFileSizeLimit = Math.min(config.maxFileSize, 20 * 1024 * 1024 // 20MB absolute maximum
    );
    const upload = multer({
        storage,
        limits: {
            fileSize: maxFileSizeLimit,
            files: config.maxFiles,
        },
        fileFilter: (_req, file, cb) => {
            if (!config.allowedMimeTypes?.length) {
                return cb(null, true);
            }
            const isAllowed = config.allowedMimeTypes.some((type) => {
                if (type.endsWith("/*")) {
                    const mainType = type.split("/")[0];
                    return file.mimetype.startsWith(`${mainType}/`);
                }
                return type === file.mimetype;
            });
            cb(null, isAllowed);
        },
    });
    if (config.fieldNames?.length) {
        const fields = config.fieldNames.map((name) => ({ name, maxCount: 1 }));
        return upload.fields(fields);
    }
    return upload.any();
}

/**
 * Prepare file upload middleware
 * Resolves file upload options from the request or server options
 * and creates multer middleware.
 *
 * @param options - Server options
 * @returns Request handler
 */
const prepareFileUpload = (options) => {
    return (req, res, next) => {
        const fileUploadOptions = typeof options.fileUpload === "function"
            ? options.fileUpload(req)
            : options.fileUpload;
        if (!fileUploadOptions?.enabled) {
            return next();
        }
        const multerMiddleware = createMulterMiddleware(fileUploadOptions);
        return multerMiddleware(req, res, next);
    };
};

async function callApiFunction(req, res) {
    const { apiFunction, args, errorHandler } = res.locals;
    try {
        const platformResponse = await apiFunction(...args);
        res.send(platformResponse);
    }
    catch (error) {
        const additionalScope = res.locals.fnOrigin
            ? { extensionName: res.locals.fnOrigin }
            : {};
        const errorBoundary = error.errorBoundary
            ? { errorBoundary: error.errorBoundary }
            : {};
        const logger = injectMetadata(getLogger(res), () => ({
            alokai: {
                scope: {
                    type: "endpoint",
                    ...additionalScope,
                },
                ...errorBoundary,
            },
        }));
        logger.error(error);
        errorHandler(error, req, res);
    }
}

/**
 * Set of helpers to faciliate working with _extensionName property
 * added on handlers added by extension's extendApiMethod hook.
 */
const markExtensionNameHelpers = {
    /**
     * Decorates handler added or overwritten by extension's extendApiMethod hook
     * with information about source extension's name
     */
    mark(apiMethod, extensionName) {
        apiMethod._extensionName = extensionName;
        return apiMethod;
    },
    /**
     * Marks a set of endpoints using `mark` method
     */
    markApi(api, extensionName) {
        return Object.entries(api).reduce((total, [name, fn]) => {
            return {
                ...total,
                [name]: markExtensionNameHelpers.mark(fn, extensionName),
            };
        }, {});
    },
    /**
     * Checks if object is marked with extension's name
     */
    has(obj) {
        return "_extensionName" in obj;
    },
    /**
     * Gets extension's name from which handler comes
     *
     * @remarks Returns undefined if it's missing in the handler
     */
    get(obj) {
        return obj?._extensionName;
    },
};

/**
 * Resolves the api function from the apiClientPromise based on the extensionName and functionName parameters.
 *
 * @param apiClientPromise
 * @param reqParams
 *
 * @returns Tuple containing resolved function and name of extension it comes from if any
 */
const getApiFunction = async (apiClientPromise, functionName, extensionName) => {
    try {
        const apiClient = await apiClientPromise;
        const apiFn = extensionName
            ? apiClient?.api?.[extensionName]?.[functionName]
            : apiClient?.api?.[functionName];
        if (!apiFn) {
            const errorMessage = extensionName
                ? `Extension "${extensionName}" is not namespaced or the function "${functionName}" is not available in the namespace.`
                : `The function "${functionName}" is not registered.`;
            throw new Error(errorMessage);
        }
        return [apiFn, markExtensionNameHelpers.get(apiFn)];
    }
    catch (error) {
        const e = new Error(`Failed to resolve apiClient or function: ${error.message}`);
        if (error.errorBoundary) {
            Object.assign(e, { errorBoundary: error.errorBoundary });
        }
        throw e;
    }
};

function prepareApiFunction(integrations) {
    return async (req, res, next) => {
        const { integrationName, extensionName, functionName } = req.params;
        const { apiClient, configuration, extensions, customQueries = {}, initConfig, } = integrations[integrationName];
        const middlewareContext = {
            req,
            res,
            extensions,
            customQueries,
            integrations,
            integrationTag: integrationName,
            getApiClient: (integrationTag) => {
                if (!(integrationTag in integrations)) {
                    const keys = Object.keys(integrations);
                    throw new Error(`The specified integration key "${integrationTag}" was not found. Available integration keys are: ${keys}. Please ensure you're using the correct key or add the necessary integration configuration.`);
                }
                const { apiClient: innerApiClient, configuration: innerConfiguration, extensions: innerExtensions, customQueries: innerCustomQueries = {}, initConfig: innerInitConfig, } = integrations[integrationTag];
                const innerMiddlewareContext = {
                    ...middlewareContext,
                    integrationTag,
                    extensions: innerExtensions,
                    customQueries: innerCustomQueries,
                };
                const createInnerApiClient = innerApiClient.createApiClient.bind({
                    middleware: innerMiddlewareContext,
                });
                const apiClientInstance = createInnerApiClient({
                    ...innerConfiguration,
                    ...innerInitConfig,
                });
                return apiClientInstance;
            },
        };
        const createApiClient = apiClient.createApiClient.bind({
            middleware: middlewareContext,
        });
        const apiClientInstance = createApiClient({
            ...configuration,
            ...initConfig,
        });
        // Pick the function from the namespaced if it exists, otherwise pick it from the shared integration
        try {
            const [fn, fnOrigin] = await getApiFunction(apiClientInstance, functionName, extensionName);
            res.locals.apiFunction = fn;
            res.locals.fnOrigin = fnOrigin;
        }
        catch (e) {
            if (e.errorBoundary) {
                const logger = injectMetadata(getLogger(res), () => ({
                    alokai: {
                        scope: {
                            type: "endpoint",
                        },
                        errorBoundary: e.errorBoundary,
                    },
                }));
                logger.error(e);
            }
            res.status(404);
            res.send(e.message);
            return;
        }
        next();
    };
}

function prepareErrorHandler(integrations) {
    return (req, res, next) => {
        const { integrationName } = req.params;
        const { errorHandler } = integrations[integrationName];
        res.locals.errorHandler = errorHandler;
        next();
    };
}

function prepareArguments(req, res, next) {
    const { method, query, body } = req;
    let args;
    if (method === "GET") {
        /**
         * Falling back to empty object to mimic
         * the behavior of express.json() middleware
         * when no POST body is provided.
         */
        const { body: queryBody = "{}" } = query;
        args = JSON.parse(queryBody);
    }
    else {
        args = body;
    }
    const argsArray = Symbol.iterator in Object(args) ? args : [args];
    res.locals.args = argsArray;
    next();
}

function prepareLogger(loggerManager) {
    return function (req, res, next) {
        if (!res.locals) {
            res.locals = {};
        }
        const logger = loggerManager.get(req?.params?.integrationName);
        if (!req?.params?.integrationName) {
            console.error("prepareLogger middleware used for unsupported route");
        }
        const { integrationName, functionName } = req.params;
        const loggerWithMetadata = injectMetadata(logger, (metadata) => {
            return {
                alokai: {
                    context: "middleware",
                    scope: {
                        integrationName,
                        functionName,
                        ...metadata?.alokai?.scope,
                    },
                },
            };
        });
        if (!res.locals.alokai) {
            res.locals.alokai = {
                logger: loggerWithMetadata,
            };
        }
        else {
            res.locals.alokai.logger = loggerWithMetadata;
        }
        next();
    };
}

function validateParams(integrations) {
    return (req, res, next) => {
        // Validate & sanitize the request params
        Object.entries(req.params).forEach(([key, value]) => {
            req.params[key] = typeof value === "string" ? xss(value) : value;
        });
        // Validate the request method
        const { method } = req;
        if (method !== "GET" && method !== "POST") {
            res.status(405);
            res.send(`Method ${method} is not allowed. Please, use GET or POST method.`);
            return;
        }
        // Validate the integration
        const { integrationName } = req.params;
        if (!integrations || !integrations[integrationName]) {
            res.status(404);
            res.send(`"${integrationName}" integration is not configured. Please, check the request path or integration configuration.`);
            return;
        }
        next();
    };
}

const createReadyzHandler = (readinessChecks) => async () => {
    // call all provided readiness checks in parallel
    // warning: because Promise.allSettled (also happens for .all()) is used,
    // all readiness checks need to return a promise (that is, need to be async functions)
    const calledReadinessChecks = await Promise.allSettled(readinessChecks.map((fn) => fn()));
    const readinessCheckFailureReasons = calledReadinessChecks.reduce((failureReasons, settledReadinessCheck) => settledReadinessCheck.status === "rejected"
        ? [...failureReasons, settledReadinessCheck.reason]
        : failureReasons, []);
    if (readinessCheckFailureReasons.length) {
        throw new HealthCheckError("Readiness check failed", readinessCheckFailureReasons);
    }
};
const createTerminusOptions = (readinessChecks = []) => {
    return {
        useExit0: true,
        // In case some requests are still being handled when SIGTERM was received, naively wait in hopes that they will be resolved in that time, and only then shut down the process
        beforeShutdown: () => setTimeout(10 ** 4),
        healthChecks: {
            verbatim: true,
            "/readyz": createReadyzHandler(readinessChecks),
        },
    };
};

const defaultCorsOptions = {
    credentials: true,
    origin: ["http://localhost:3000", "http://localhost:4000"],
};
async function createServer(config, options = {}) {
    const loggerManager = new LoggerManager(config, (loggerConfig) => lockLogger(LoggerFactory.create(LoggerType.ConsolaGcp, loggerConfig)));
    const logger = injectMetadata(loggerManager.get(), () => ({
        alokai: {
            context: "middleware",
        },
    }));
    const app = express();
    // app.use(createMulterMiddleware(options.fileUpload));
    app.use(express.json(options.bodyParser));
    app.use(options.cookieParser
        ? cookieParser(options.cookieParser.secret, options.cookieParser.options)
        : cookieParser());
    app.use(cors(options.cors ?? defaultCorsOptions));
    app.disable("x-powered-by");
    logger.info("Middleware starting....");
    const helmetOptions = {
        contentSecurityPolicy: false,
        crossOriginOpenerPolicy: false,
        crossOriginEmbedderPolicy: false,
        permittedCrossDomainPolicies: {
            permittedPolicies: "none",
        },
        ...(config.helmet || {}),
    };
    const isHelmetEnabled = config.helmet === true ||
        (config.helmet && Object.keys(config.helmet).length > 0);
    if (isHelmetEnabled) {
        app.use(helmet(helmetOptions));
        logger.debug("VSF `Helmet` middleware added");
    }
    logger.debug("Loading integrations...");
    const integrations = await registerIntegrations(app, config.integrations, loggerManager);
    logger.debug("Integrations loaded!");
    app.all("/:integrationName/:extensionName?/:functionName", validateParams(integrations), prepareFileUpload(options), prepareLogger(loggerManager), prepareApiFunction(integrations), prepareErrorHandler(integrations), prepareArguments, callApiFunction);
    // This could instead be implemented as a healthcheck within terminus, but we don't want /healthz to change response if app received SIGTERM
    app.get("/healthz", (_req, res) => {
        res.end("ok");
    });
    const server = http.createServer(app);
    createTerminus(server, createTerminusOptions(options.readinessProbes));
    logger.info("Middleware created!");
    return server;
}

const createExtendQuery = (context) => (customQuery, defaults) => {
    const { customQueries = {} } = context;
    const { metadata = {} } = customQuery || {};
    return Object.entries(defaults).reduce((prev, [queryName, initialArgs]) => {
        const key = customQuery?.[queryName];
        const queryFn = (key && customQueries[key]) || (() => initialArgs);
        return {
            ...prev,
            [queryName]: queryFn({ ...initialArgs, metadata }),
        };
    }, {});
};

/**
 * @param fn Function to be wraped.
 * @param errorBoundaryProvider Factory function providing value of errorBoundary to be injected
 * @returns Decorated provided async function with catch block extending error with
 * "errorBoundary" property equal value derived from errorBoundaryProvider factory.
 */
function wrapFnWithErrorBoundary(fn, errorBoundaryProvider) {
    return async (...args) => {
        try {
            const response = await fn(...args);
            return response;
        }
        catch (err) {
            Object.assign(err, { errorBoundary: errorBoundaryProvider(err) });
            throw err;
        }
    };
}
/**
 * @param fn Function to be wraped.
 * @param errorBoundaryProvider Factory function providing value of errorBoundary to be injected
 * @returns Decorated provided sync function with catch block extending error with
 * "errorBoundary" property equal value derived from errorBoundaryProvider factory.
 */
function wrapFnWithErrorBoundarySync(fn, errorBoundaryProvider) {
    return (...args) => {
        try {
            const response = fn(...args);
            return response;
        }
        catch (err) {
            Object.assign(err, { errorBoundary: errorBoundaryProvider(err) });
            throw err;
        }
    };
}

const nopBefore = ({ args }) => args;
const nopAfter = ({ response, }) => response;
/**
 * @returns Instance of Logger with injected metadata of currently called handler and it's integration
 */
function injectHandlerMetadata(context, fn, callName) {
    return injectMetadata(getLogger(context), () => ({
        alokai: {
            scope: {
                type: "endpoint",
                /**
                 * The following lines ensure proper functionality in case of orchestration.
                 * In this scenario, there are multiple self-invocations of the function template we see here.
                 * Adding the currently known functionName and integrationName prevents scope confusion
                 * between different recurrent synchronous and parallel invocations (e.g., multiple orchestrated methods
                 * executed with Promise.all).
                 */
                functionName: callName,
                integrationName: context.integrationTag,
                ...(markExtensionNameHelpers.has(fn)
                    ? { extensionName: markExtensionNameHelpers.get(fn) }
                    : {}),
            },
        },
    }));
}
/**
 * Wraps api methods with context and hooks triggers
 */
const applyContextToApi = (api, context, 
/**
 * By default we use NOP function for returning the same parameters as they come.
 * It's useful in extensions, when someone don't want to inject into changing arguments or the response,
 * in that case, we use default function, to handle that scenario - NOP
 */
hooks = { before: nopBefore, after: nopAfter }) => Object.entries(api).reduce((prev, [callName, fn]) => ({
    ...prev,
    [callName]: (() => {
        const logger = injectHandlerMetadata(context, fn, callName);
        /**
         * Endpoint's handler decorated with:
         * - hooks from every extension (hooks.before contains merged beforeCall's,
         *   hooks.after contains merged afterCall's),
         * - logger with metadata about scope of call (covers orchestrated parallely called endpoints),
         * - support for building error boundary (covers orchestrated parallely called endpoints),
         */
        const handler = async (...args) => {
            const transformedArgs = await hooks.before({
                callName,
                args,
            });
            const fnWithErrorBoundary = wrapFnWithErrorBoundary(fn, (err) => {
                /**
                 * Handlers can call different handlers, so error could be already bubbling.
                 * That's why we check for presence of err.errorBoundary at first.
                 *
                 * ```ts
                 * async function myEndpoint(context) {
                 *  const int = await context.getApiClient("some_integration");
                 *  return await int.api.throwError(); // Bubbling from other integration's endpoint
                 * }
                 * ```
                 */
                const errorBoundary = err.errorBoundary || {
                    type: "endpoint",
                    functionName: callName,
                    integrationName: context.integrationTag,
                    ...(markExtensionNameHelpers.has(fn)
                        ? { extensionName: markExtensionNameHelpers.get(fn) }
                        : {}),
                };
                return errorBoundary;
            });
            const apiClientContext = {
                ...context,
                extendQuery: createExtendQuery(context),
                logger,
            };
            const response = await fnWithErrorBoundary(apiClientContext, ...transformedArgs);
            const transformedResponse = await hooks.after({
                callName,
                args,
                response,
            });
            return transformedResponse;
        };
        /**
         * Marks decorated handler with name of integration's extension
         * from which original handler was defined, if any
         */
        if (markExtensionNameHelpers.has(fn)) {
            markExtensionNameHelpers.mark(handler, markExtensionNameHelpers.get(fn));
        }
        return handler;
    })(),
}), {});

/**
 * Utility function faciliating building Logger with injected metadata about currently called hook
 */
function injectHookMetadata(logger, { extensionName, hookName, integrationName, type = "requestHook", }) {
    return injectMetadata(logger, () => ({
        alokai: {
            scope: {
                hookName,
                type,
                ...(extensionName ? { extensionName } : {}),
                ...(integrationName ? { integrationName } : {}),
            },
        },
    }));
}
const apiClientFactory = (factoryParams) => {
    const resolveApi = async (api, settings) => {
        if (typeof api === "function") {
            return await api(settings);
        }
        return api ?? {};
    };
    const createApiClient = async function createApiClient(config, customApi = {}) {
        const rawExtensions = this?.middleware?.extensions || [];
        const logger = getLogger(this.middleware.res);
        const lifecycles = await Promise.all(rawExtensions
            .filter((extension) => isFunction(extension?.hooks))
            .map(async ({ name, hooks }) => {
            // Attaching extension related metadata to the logger
            // We cannot assign it to res.locals as we would end up
            // with incorrect logger for hook functions (like beforeCreate)
            // in case of multiple extensions using hooks property
            const loggerWithMetadata = injectHookMetadata(logger, {
                hookName: "hooks",
                extensionName: name,
            });
            const hooksWithErrorBoundary = wrapFnWithErrorBoundarySync(hooks, () => ({
                type: "requestHook",
                hookName: "hooks",
                extensionName: name,
                integrationName: this?.middleware?.integrationTag,
            }));
            return {
                ...hooksWithErrorBoundary(this?.middleware?.req, this?.middleware?.res, {
                    logger: loggerWithMetadata,
                }),
                name,
            };
        }));
        const _config = await lifecycles
            .filter((extension) => isFunction(extension?.beforeCreate))
            .reduce(async (configSoFar, extension) => {
            const resolvedConfig = await configSoFar;
            const loggerWithMetadata = injectHookMetadata(logger, {
                extensionName: extension.name,
                hookName: "beforeCreate",
            });
            const beforeCreateWithErrorBoundary = wrapFnWithErrorBoundary(extension.beforeCreate, () => ({
                type: "requestHook",
                hookName: "beforeCreate",
                extensionName: extension.name,
                integrationName: this?.middleware?.integrationTag,
            }));
            return beforeCreateWithErrorBoundary({
                configuration: resolvedConfig,
                logger: loggerWithMetadata,
            });
        }, Promise.resolve(config));
        const loggerWithMetadata = injectHookMetadata(logger, {
            hookName: "onCreate",
            integrationName: this.middleware?.integrationTag,
        });
        const onCreateWithErrorBoundadry = wrapFnWithErrorBoundary(factoryParams.onCreate, () => ({
            type: "endpoint",
            hookName: "onCreate",
            integrationName: this.middleware?.integrationTag,
        }));
        const settings = factoryParams.onCreate
            ? await onCreateWithErrorBoundadry(_config, {
                logger: loggerWithMetadata,
            })
            : { config, client: config.client };
        settings.config = await lifecycles
            .filter((extension) => isFunction(extension?.afterCreate))
            .reduce(async (configSoFar, extension) => {
            const resolvedConfig = await configSoFar;
            const loggerWithMetadata = injectHookMetadata(logger, {
                extensionName: extension.name,
                hookName: "afterCreate",
            });
            const afterCreateWithErrorBoundary = wrapFnWithErrorBoundary(extension.afterCreate, () => ({
                type: "requestHook",
                hookName: "afterCreate",
                extensionName: extension.name,
                integrationName: this?.middleware?.integrationTag,
            }));
            return afterCreateWithErrorBoundary({
                configuration: resolvedConfig,
                logger: loggerWithMetadata,
            });
        }, Promise.resolve(settings.config));
        const extensionHooks = {
            before: async (params) => {
                return await lifecycles
                    .filter((extension) => isFunction(extension?.beforeCall))
                    .reduce(async (argsSoFar, extension) => {
                    const resolvedArgs = await argsSoFar;
                    const resolvedSettings = await settings;
                    const loggerWithMetadata = injectHookMetadata(logger, {
                        extensionName: extension.name,
                        hookName: "beforeCall",
                    });
                    const beforeCallWithErrorBoundary = wrapFnWithErrorBoundary(extension.beforeCall, () => ({
                        type: "requestHook",
                        hookName: "beforeCall",
                        extensionName: extension.name,
                        functionName: params.callName,
                        integrationName: this?.middleware?.integrationTag,
                    }));
                    return beforeCallWithErrorBoundary({
                        ...params,
                        configuration: resolvedSettings.config,
                        args: resolvedArgs,
                        logger: loggerWithMetadata,
                    });
                }, Promise.resolve(params.args));
            },
            after: async (params) => {
                return await lifecycles
                    .filter((extension) => isFunction(extension.afterCall))
                    .reduce(async (responseSoFar, extension) => {
                    const resolvedResponse = await responseSoFar;
                    const resolvedSettings = await settings;
                    const loggerWithMetadata = injectHookMetadata(logger, {
                        extensionName: extension.name,
                        hookName: "afterCall",
                    });
                    const afterCallWithErrorBoundary = wrapFnWithErrorBoundary(extension.afterCall, () => ({
                        type: "requestHook",
                        hookName: "afterCall",
                        extensionName: extension.name,
                        functionName: params.callName,
                        integrationName: this?.middleware?.integrationTag,
                    }));
                    return afterCallWithErrorBoundary({
                        ...params,
                        configuration: resolvedSettings.config,
                        response: resolvedResponse,
                        logger: loggerWithMetadata,
                    });
                }, Promise.resolve(params.response));
            },
        };
        const context = { ...settings, ...(this?.middleware || {}) };
        const api = await resolveApi(factoryParams.api, settings);
        const namespacedExtensions = {};
        let sharedExtensions = customApi;
        for await (const extension of rawExtensions) {
            const extendedApiMethods = await resolveApi(extension.extendApiMethods, settings);
            if (extension.isNamespaced) {
                const markedExtendedApiMethods = markExtensionNameHelpers.markApi(extendedApiMethods, extension.name);
                namespacedExtensions[extension.name] = {
                    ...(namespacedExtensions?.[extension.name] ?? {}),
                    ...markedExtendedApiMethods,
                };
            }
            else {
                const markedExtendedApiMethods = markExtensionNameHelpers.markApi(extendedApiMethods, extension.name);
                sharedExtensions = {
                    ...sharedExtensions,
                    ...markedExtendedApiMethods,
                };
            }
        }
        const integrationApi = applyContextToApi(api, context, extensionHooks);
        const sharedExtensionsApi = applyContextToApi(sharedExtensions, context, extensionHooks);
        const namespacedApi = {};
        for (const [namespace, extension] of Object.entries(namespacedExtensions)) {
            namespacedApi[namespace] = applyContextToApi(extension, context, extensionHooks);
        }
        const extendedApi = {
            ...sharedExtensionsApi,
            ...namespacedApi,
        };
        const mergedApi = {
            ...integrationApi,
            ...extendedApi,
        };
        // api methods haven't been invoked yet, so we still have time to add them to the context
        context.api = integrationApi;
        context.extendedApi = extendedApi;
        return {
            api: mergedApi,
            client: settings.client,
            settings: settings.config,
        };
    };
    createApiClient._predefinedExtensions = factoryParams.extensions || [];
    return { createApiClient };
};

export { apiClientFactory, createReadyzHandler, createServer, createTerminusOptions, defaultErrorHandler, getLogger };
//# sourceMappingURL=index.es.js.map
