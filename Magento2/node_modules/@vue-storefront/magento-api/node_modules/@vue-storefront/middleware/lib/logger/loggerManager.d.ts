import type { LoggerInterface } from "@vue-storefront/logger";
import type { IntegrationContext, MiddlewareConfig } from "../types";
/**
 * Internal class responsible for spawning minimal amount of Logger's instances
 * on boostrap of the application.
 *
 * @example Spawning minimal amount of Logger's instances and accessing it
 * ```ts
 * const config = // ... it's whole middleware's config
 * const buildLogger = (loggerConfig) => LoggerFactory.create(LoggerType.ConsolaGcp, loggerConfig); // function responsible for creating new instance of Logger, it gets already resolved configuration for new instance as an argument
 *
 * const loggerManager = new LoggerManager(
 *  config,
 *  buildLogger
 * );
 * ```
 */
export declare class LoggerManager<TLoggerConfig = unknown> {
    private instances;
    constructor(config: MiddlewareConfig<Record<string, IntegrationContext>>, buildLogger: (logger: TLoggerConfig) => LoggerInterface);
    /**
     * Merges integration's logger config with global's logger config
     */
    private mergeConfigs;
    /**
     * Selects custom logger provided by user with fallback to default logger.
     * Prints console.warn if provided redudant custom options with custom handler.
     */
    private selectLogger;
    /**
     * Check if integration's config has configuration for dedicated logger instance.
     */
    private hasCustomLoggerConfig;
    /**
     * Returns instance of logger for requested integration from internal storage.
     * Called without an argument returns instance of global logger.
     */
    get(integrationName?: string): LoggerInterface;
}
//# sourceMappingURL=loggerManager.d.ts.map