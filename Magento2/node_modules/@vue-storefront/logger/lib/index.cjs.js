'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var consola = require('consola');
var dotenv = require('dotenv');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var dotenv__default = /*#__PURE__*/_interopDefaultLegacy(dotenv);

const removeAnsiColorCodesFromStr = (str) => {
    // eslint-disable-next-line no-control-regex
    const ansiRegex = /\x1B\[[0-?9;]*[mK]/g;
    return str.replace(ansiRegex, "");
};

/**
 * A structured log for Google Cloud Platform.
 */
class GCPStructuredLog {
    constructor(removeAnsiCodes = removeAnsiColorCodesFromStr) {
        /**
         * The mapping of log levels to GCP severity levels.
         */
        this.severityMap = {
            emergency: "EMERGENCY",
            alert: "ALERT",
            critical: "CRITICAL",
            error: "ERROR",
            warning: "WARNING",
            notice: "NOTICE",
            info: "INFO",
            debug: "DEBUG",
        };
        this.removeAnsiCodes = removeAnsiCodes;
    }
    /**
     * Creates a structured log object for GCP.
     */
    createLog(logData, options, severity, metadata = {}) {
        const structuredDto = {
            timestamp: this.getCurrentTimestamp(),
            severity: this.mapLogVerbosityToGCPSeverity(severity),
            message: this.formatMessage(logData),
            ...metadata,
        };
        if (logData instanceof Error) {
            const stackTrace = options.includeStackTrace
                ? this.extractTrace(logData)
                : undefined;
            if (stackTrace) {
                structuredDto.stackTrace = stackTrace;
            }
        }
        return structuredDto;
    }
    /**
     * @returns The current timestamp in ISO 8601 format.
     */
    getCurrentTimestamp() {
        return new Date().toISOString();
    }
    /**
     *
     * @returns The GCP severity level for the given log level.
     */
    mapLogVerbosityToGCPSeverity(level) {
        return this.severityMap[level] || "DEFAULT";
    }
    /**
     *
     * @returns The formatted log message.
     */
    formatMessage(logData) {
        let message = "";
        if (logData instanceof Error) {
            message = logData.message;
        }
        else if (typeof logData === "string") {
            message = logData;
        }
        else {
            message = JSON.stringify(logData);
        }
        return this.removeAnsiCodes(message);
    }
    /**
     * @returns The stack trace if the log data is an error.
     */
    extractTrace(logData) {
        return logData instanceof Error ? logData.stack : undefined;
    }
}

const jsonReporter = (logObject) => {
    const defLogType = "log";
    const logType = logObject?.type ?? defLogType;
    const logFn = console[logType] ?? console[defLogType];
    if (process.env.NODE_ENV === "development" || typeof window !== "undefined") {
        logFn(logObject.args[0].structuredLog);
    }
    else {
        logFn(JSON.stringify(logObject.args[0].structuredLog));
    }
};

// We do not want to load the .env in the browser and in the edge runtime
if (typeof window === "undefined" && process.env.NEXT_RUNTIME !== "edge") {
    dotenv__default["default"].config();
}
const createConsolaStructuredLogger = (structuredLog, options = {
    verbosity: "info",
    includeStackTrace: true,
}) => {
    const levelMap = {
        emergency: 0,
        alert: 0,
        critical: 0,
        error: 0,
        warning: 1,
        notice: 2,
        info: 3,
        debug: 4,
    };
    const buildJsonReporter = () => {
        return {
            log: jsonReporter,
        };
    };
    const logger = consola.createConsola({
        level: levelMap?.[options.verbosity] ?? levelMap.info,
        reporters: options.reporters || [buildJsonReporter()],
    });
    if (options.reporters) {
        logger.setReporters(options.reporters);
    }
    const mapToConsolaLevel = (level) => {
        return levelMap?.[level] ?? levelMap.info; // Default to 'info' level
    };
    const logStructured = (level, logData, metadata) => {
        const structuredLogEntry = structuredLog.createLog(logData, options, level, metadata);
        /**
         * Map the log level to the consola level
         * Our log levels are more granular than consola's log levels
         * and we need to map them to the closest consola level
         */
        const consolaLevel = mapToConsolaLevel(level);
        switch (consolaLevel) {
            case 0:
                logger.error({ structuredLog: structuredLogEntry });
                break;
            case 1:
                logger.warn({ structuredLog: structuredLogEntry });
                break;
            case 2:
                logger.log({ structuredLog: structuredLogEntry });
                break;
            case 3:
                logger.info({ structuredLog: structuredLogEntry });
                break;
            case 4:
                logger.debug({ structuredLog: structuredLogEntry });
                break;
            default:
                logger.info(structuredLogEntry);
                break;
        }
    };
    const log = (level, logData, metadata) => {
        logStructured(level, logData, metadata);
    };
    const logAtLevel = (level) => {
        return (logData, metadata) => log(level, logData, metadata);
    };
    const emergency = logAtLevel("emergency");
    const alert = logAtLevel("alert");
    const critical = logAtLevel("critical");
    const error = logAtLevel("error");
    const warning = logAtLevel("warning");
    const notice = logAtLevel("notice");
    const info = logAtLevel("info");
    const debug = logAtLevel("debug");
    return {
        emergency,
        alert,
        critical,
        error,
        warning,
        notice,
        info,
        debug,
    };
};

exports.LoggerType = void 0;
(function (LoggerType) {
    LoggerType["ConsolaGcp"] = "consola-gcp";
})(exports.LoggerType || (exports.LoggerType = {}));
/**
 * Creates a logger based on the type
 * Available types:
 * - consola-gcp (Consola logger with GCP structured log)
 *
 * @param type The type of logger to create
 */
class LoggerFactory {
    static create(type, options) {
        const defaultOptions = {
            verbosity: "info",
            includeStackTrace: false,
        };
        const mergedOptions = {
            ...defaultOptions,
            ...options,
        };
        switch (type) {
            case exports.LoggerType.ConsolaGcp:
                return createConsolaStructuredLogger(new GCPStructuredLog(), mergedOptions);
            default:
                throw new Error(`Logger type ${type} is not supported`);
        }
    }
}

exports.LoggerFactory = LoggerFactory;
//# sourceMappingURL=index.cjs.js.map
